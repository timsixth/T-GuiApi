package pl.timsixth.guilibrary.core.model.pagination;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import org.bukkit.Material;
import pl.timsixth.guilibrary.core.model.BaseMenu;
import pl.timsixth.guilibrary.core.model.Generable;
import pl.timsixth.guilibrary.core.model.MenuItem;
import pl.timsixth.guilibrary.core.model.action.custom.NextPageAction;
import pl.timsixth.guilibrary.core.model.action.custom.PreviousPageAction;
import pl.timsixth.guilibrary.core.util.ChatUtil;

import java.util.*;
import java.util.stream.Collectors;

@Getter
@Setter
@ToString
public class PaginatedMenu extends BaseMenu implements Cloneable {

    private int itemsPerPage;
    private int currentPage = 0;
    private List<Page> pages;
    private List<MenuItem> staticItems;
    private List<? extends Generable> data;

    public static final MenuItem DEFAULT_NEXT_PAGE_ITEM = MenuItem.builder()
            .material(Material.ARROW)
            .displayName(ChatUtil.chatColor("&aClick to move to next page"))
            .slot(8)
            .action(new NextPageAction())
            .build();

    public static final MenuItem DEFAULT_PREVIOUS_PAGE_ITEM = MenuItem.builder()
            .material(Material.ARROW)
            .displayName(ChatUtil.chatColor("&aClick to move to previous page"))
            .action(new PreviousPageAction())
            .slot(7)
            .build();

    public PaginatedMenu(int size, String name, String displayName) {
        super(size, name, displayName);

        pages = new ArrayList<>();
        staticItems = new ArrayList<>();
    }

    /**
     * Adds default static items.
     * Items: NEXT_PAGE_ITEM and PREVIOUS_PAGE_ITEM
     */
    public void useDefaultStaticItems() {
        staticItems.add(DEFAULT_NEXT_PAGE_ITEM);
        staticItems.add(DEFAULT_PREVIOUS_PAGE_ITEM);
    }

    /**
     * Gets next page
     *
     * @return optional of next page
     */
    public Optional<Page> nextPage() {
        currentPage++;

        if (currentPage == pages.size()) {
            currentPage = 0;
            return Optional.ofNullable(pages.get(0));
        }

        return Optional.ofNullable(pages.get(currentPage));
    }

    /**
     * Gets previous page
     *
     * @return optional of previous page
     */
    public Optional<Page> previousPage() {
        currentPage--;

        if (currentPage == -1) {
            currentPage = 0;
            return Optional.ofNullable(pages.get(0));
        }

        return Optional.ofNullable(pages.get(currentPage));
    }

    /**
     * Gets first page
     *
     * @return optional of first page
     */
    public Optional<Page> firstPage() {
        if (pages.isEmpty()) return Optional.empty();

        return Optional.ofNullable(pages.get(0));
    }

    /**
     * Sets number of items per page
     *
     * @param itemsPerPage items per page
     */
    public void setItemsPerPage(int itemsPerPage) {
        if (itemsPerPage <= 0) throw new IllegalArgumentException("Items per page can not be zero");

        this.itemsPerPage = itemsPerPage;
    }

    /**
     * Generates pages
     *
     * @return latest index of page which was generated by not extra page method
     */
    public int generatePages() {
        if (itemsPerPage > getSize()) {
            throw new IllegalStateException("Number of items per page can not be greater than inventory size");
        }

        if (!pages.isEmpty()) {
            pages.clear();
        }

        if (data.size() < itemsPerPage) {
            createPage(0);

            return -1;
        }

        if (data.size() > itemsPerPage) {
            int latestIndex = 0;
            int amountOfPages = data.size() / itemsPerPage;

            for (int i = 0; i < amountOfPages; i++) {
                createPage(i);
                latestIndex = i;
            }

            return latestIndex;
        }

        return 0;
    }

    /**
     * Creates page
     *
     * @param index index to create unique name of page
     * @return created page
     */
    private Page createPage(int index) {
        Page page = new Page(getSize(), createUniqueName(index), getDisplayName() + " #" + (index + 1));

        page.setPaginatedMenu(this);

        staticItems.forEach(item -> item.setParentMenu(page));

        pages.add(page);

        return page;
    }

    /**
     * Sets page data
     *
     * @param page        page to set data
     * @param latestIndex latest index of element in data list
     * @return latest index of element in data list
     */
    public int setPageData(Page page, int latestIndex) {
        Set<MenuItem> items = new HashSet<>();
        List<Integer> staticItemsSlots = getStaticItemsSlots();

        List<Generable> omitItems = new ArrayList<>();

        int slot = 0;
        for (int i = latestIndex; i < data.size(); i++) {
            if (staticItemsSlots.contains(slot)) {
                omitItems.add(data.get(i));
                slot++;
                continue;
            }

            if ((items.size() + omitItems.size()) == itemsPerPage) {
                latestIndex = i;
                break;
            }

            items.add(data.get(i).getGeneratedItem(slot));

            slot++;
        }

        for (Generable item : omitItems) {
            items.add(item.getGeneratedItem(slot));
            slot++;
        }

        page.setItems(items);

        return latestIndex;
    }

    /**
     * Creates unique name for page
     *
     * @param index index of page, it's begin of 0 to amount of pages (size of data list divided by items per page)
     * @return unique name
     */
    private String createUniqueName(int index) {
        return index + "page" + getName();
    }

    /**
     * Gets list of static items slots
     *
     * @return list of static items slots
     */
    private List<Integer> getStaticItemsSlots() {
        return staticItems.stream()
                .map(MenuItem::getSlot)
                .collect(Collectors.toList());
    }

    /**
     * Gets item count form pages
     *
     * @return items count
     */
    public int getPagesItemCount() {
        return pages.stream()
                .mapToInt(page -> page.getItems().size())
                .sum();
    }

    /**
     * Creates extra page, when list of data is greater than list of static items
     *
     * @param latestIndex latest index of element in data list
     * @return generated page
     */
    public Page generateExtraPage(int latestIndex) {
        return createPage(latestIndex);
    }

    @Override
    public PaginatedMenu clone() {
        try {
            return (PaginatedMenu) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
